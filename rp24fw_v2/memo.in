/* memo.in                                              */
/********************************************************/
/* object    | use4memo                                 */
/* abstract  | memo                                     */
/* edit his  | 2025/12/07 テンプレート作成 ver1.0       */
/*           |                                          */
/********************************************************/
■v1.0でやりたいこと

・抽象化層とMCU依存層，吸収層の分離

■v2.0でやりたいこと
・OS APIとMCU依存の分離．
-m00で編集予定のファイルを切り分け済．
現在はrp24依存のレジスタベタ打ちと，
RTOSカーネルが混合しているため切り分けたい．



/****************/
/*     app      */ 抽象化
/****************/
/*     drv      */ 入出力論理デバイス
/****************/
/*     hal      */ GPIO TIMER UART 等の吸収
/****************/
/*     os       */ μItron機能
/****************/
/*     pf       */ MCU依存(現在rp24依存)
/****************/
/*    core      */ 基礎事項定義
/****************/




マイコン: rp2040 (OEM-edi)

OS      : μ-Itron

ハードウェア : ボタン４つ LED４つ モーター？

機能    : ボタン４つ → アクセル ブレーキ アップ ダウン
        : 4つモード搭載してLEDでモードを表現
        : アクセル ブレーキでモータを制御

モード  : low middle high overdrive  

 -----------------------------------------------------
|                                                     |
|   L L L L                                           |
|                                                     |
|   b b b b                                           |
 -----------------------------------------------------



構造
・モード判定
初期はlowモードで初期化．
upボタン，downボタンの入力でモードを遷移する．
モード状態を公開する
ボタンが3秒以上押されていたら固着状態をONにする．
固着状態の場合，ボタン操作は受け付けない．
・動力操作
初期は出力０で初期化
アクセルで回転数アップ，ブレーキで回転数ダウン
ボタン押下と回転数の関係は別途構想予定．

250128 usermain()関数から見ていく．
flgid = tk_cre_flg(&cflg)
T_CFLG cflg =
{
        .flgptn = TA_TFIFO | TA_WMUL,    // イベントフラグ属性
        .iflgptn    = 0,     // イベントフラグ初期値
}
cflg構造体のポインタを引数として渡す．
ID tk_cre_flg( const T_CFLG *pk_cflg )
{
    ID   flgid;   |flgid宣言
    UINT intsts;  |intsts宣言
    DI(intsts);   |割禁
    for(flgid = 0; flgcb_tbl[flgid].state |  FLGCB flgcb_tbl[CNF_MAX_FLGID];の配列
        != KS_NONEXIST; flgid++)          |  KS_NONEXISTじゃない間は配列増やす
    { 
        ;
    }
    if(flgid < CNF_MAX_FLGID)         
    {
        flgcb_tbl[flgid].state = KS_EXIST;  フラグ情報を存在に
        flgcb_tbl[flgid].flgptn = pk_cflg -> iflgptn; 
        flgid++;
    }
    else
    {
        flgid = E_LIMIT;
    }
    EI(intsts);
    return flgid;
}

tk_cre_sem
ID tk_cre_sem( const T_CSEM *pk_csem )
{
    ID      semid;
    UINT    intsts;

    DI(intsts);     // 割込み禁止
    for(semid = 0; semcb_tbl[semid].state != KS_NONEXIST; semid++); セット可能まで進む

    if(semid < CNF_MAX_SEMID) {
        /* セマフォ管理情報の初期化 */
        semcb_tbl[semid].state  = KS_EXIST;
        semcb_tbl[semid].semcnt = pk_csem->isemcnt;
        semcb_tbl[semid].maxsem = pk_csem->maxsem;
        semid++;
    } else {
        semid = E_LIMIT;
    }
    EI(intsts);      // 割込み許可
    return semid;
}


/********************************************************/
/* EOF                                                  */
/********************************************************/
